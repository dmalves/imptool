;;; $Id: dithering.scm,v 1.3 2013/03/02 15:54:41 daniel Exp daniel $
;;; $Name:  $

(declare
 (standard-bindings)
 (block)
 (not safe)
 (fixnum)
 (inline)
 (inlining-limit 10000)
 (constant-fold)
 (proper-tail-calls))

;;; +DESCRIPTION-------------------------------------------------------------------------+
;;; |dithering:                                                                          |
;;; |it performs algoritms on a gray scale image                                         |
;;; +INPUT-------------------------------------------------------------------------------+
;;; |img-gray: gray scale image                                                          |
;;; +OUTPUT------------------------------------------------------------------------------+
;;; |a halftoning gray scale image                                                       |
;;; +------------------------------------------------------------------------------------+
(define (dithering-gray method img-gray)

  (define  (get-sign x)
    (if (negative? x) -1 1))

  (define (build-floyd-steinberg-luts)
    (let* ((lut-1-16 (make-u8lut 256 (lambda (x)
                                       (exact-round (/ x 16)))))
           (lut-3-16 (make-u8lut 256 (lambda (x)
                                       (* 3 (lut-1-16 x)))))
           (lut-5-16 (make-u8lut 256 (lambda (x)
                                       (* 5 (lut-1-16 x)))))
           (lut-7-16 (make-u8lut 256 (lambda (x)
                                       (* 7 (lut-1-16 x))))))
      (list lut-1-16 lut-3-16 lut-5-16 lut-7-16)))

  (define (build-sierra-filter-lite-luts)
    (let* ((lut-1-4 (make-u8lut 256 (lambda (x)
                                      (exact-round (/ x 4)))))
           (lut-2-4 (make-u8lut 256 (lambda (x)
                                      (* 2 (lut-1-4 x))))))
      (list lut-1-4 lut-2-4)))

  (define (floyd-steinberg img-gray)
    (let* ((rows (image-rows img-gray)) (cols (image-cols img-gray))
           (vec (u8vector-copy  (image-channel-vector img-gray 0)))
           (img2 (make-gray-image cols rows)) (vec2 (image-channel-vector img2 0))
           (oldpixel 0) (newpixel 0) (quant-error 0) (pixel 0) (sign 0)
           (get-sign (lambda (x) (if (negative? x) -1 1)))
           (find-closest-color (lambda (color)
                                 (if (> color 128) 255 0)))
           (lut-closest (make-u8lut 256 (lambda (color)
                                          (find-closest-color color))))
           (floyd-luts (build-floyd-steinberg-luts))
           (lut-1-16 (list-ref floyd-luts 0))
           (lut-3-16 (list-ref floyd-luts 1))
           (lut-5-16 (list-ref floyd-luts 2))
           (lut-7-16 (list-ref floyd-luts 3)))

      (let loop-y ((y 0))
        (cond ((fx< y rows)
               (let loop-x ((x 0))
                 (cond ((fx< x cols)
                        (set! oldpixel (u8vector/2d-ref vec cols x y))
                        (set! newpixel (lut-closest oldpixel))
                        (u8vector/2d-set! vec2 cols x y newpixel)
                        (set! quant-error (fx- oldpixel newpixel))
                        (set! sign (get-sign quant-error))
                        (set! quant-error (abs quant-error))
                        (cond ((and (fx< (fx+ x 1) cols) (fx< (fx+ y 1) rows))
                               (set! pixel (u8vector/2d-ref vec cols (fx+ x 1) y))
                               (u8vector/2d-set! vec cols (fx+ x 1) y (u8fit (+ pixel (* sign (lut-7-16 quant-error)))))
                               (set! pixel (u8vector/2d-ref vec cols (fx- x 1) (fx+ y 1)))
                               (u8vector/2d-set! vec cols (fx- x 1) (fx+ y 1) (u8fit (+ pixel (* sign (lut-3-16 quant-error)))))
                               (set! pixel (u8vector/2d-ref vec cols x (fx+ y 1)))
                               (u8vector/2d-set! vec cols x (fx+ y 1) (u8fit (+ pixel (* sign (lut-5-16 quant-error)))))
                               (set! pixel (u8vector/2d-ref vec cols (fx+ x 1) (fx+ y 1)))
                               (u8vector/2d-set! vec cols (fx+ x 1) (fx+ y 1) (u8fit (+ pixel (* sign (lut-1-16 quant-error)))))))
                        (loop-x (fx+ x 1)))))
               (loop-y (fx+ y 1)))
              (#t img2)))))

  ;; on this version we randomly choose where to add the error
  (define (floyd-steinberg-random img-gray)
    (let* ((rows (image-rows img-gray)) (cols (image-cols img-gray))
           (img (image-copy img-gray)) (mat (image-channel-matrix img 0))
           (img2 (make-gray-image cols rows)) (mat2 (image-channel-matrix img2 0))
           (oldpixel 0) (newpixel 0) (quant-error 0) (pixel 0) (seed 0)
           (find-closest-color (lambda (color)
                                 (if (> color 128) 255 0)))
           (lut-closest (make-u8lut 256 (lambda (color)
                                          (find-closest-color color)))))
      (let loop-y ((y 0))
        (cond ((fx< y rows)
               (let loop-x ((x 0))
                 (cond ((fx< x cols)
                        (set! oldpixel (matrix-ref mat x y))
                        (set! newpixel (u8fit (lut-closest oldpixel)))
                        (matrix-set! mat2 x y newpixel)
                        (set! quant-error (- oldpixel newpixel))
                        (cond ((and (fx< (fx+ x 1) cols) (fx< (fx+ y 1) rows))
                               (set! seed (random-integer 4))
                               (cond ((= seed 0)
                                      (set! pixel (matrix-ref mat (fx+ x 1) y))
                                      (matrix-set! mat (fx+ x 1) y (u8fit (+ pixel quant-error))))
                                     ((= seed 1)
                                      (set! pixel (matrix-ref mat (fx+ x -1) (fx+ y 1)))
                                      (matrix-set! mat (fx+ x -1) (fx+ y 1) (u8fit (+ pixel quant-error))))
                                     ((= seed 2)
                                      (set! pixel (matrix-ref mat x (fx+ y 1)))
                                      (matrix-set! mat x (fx+ y 1) (u8fit (+ pixel quant-error))))
                                     ((= seed 3)
                                      (set! pixel (matrix-ref mat (fx+ x 1) (fx+ y 1)))
                                      (matrix-set! mat (fx+ x 1) (fx+ y 1) (u8fit (+ pixel quant-error)))))))
                        (loop-x (fx+ x 1)))))
               (loop-y (fx+ y 1)))
              (#t img2)))))

  ;; on this version we use 4 color levels
  (define (floyd-steinberg-4-colors img-gray)
    (let* ((rows (image-rows img-gray)) (cols (image-cols img-gray))
           (img (image-copy img-gray)) (mat (image-channel-matrix img 0))
           (img2 (make-gray-image cols rows)) (mat2 (image-channel-matrix img2 0))
           (oldpixel 0) (newpixel 0) (quant-error 0) (pixel 0) (sign 0)
           (find-closest-color (lambda (color)
                                 (cond ((< color 64)
                                        0)
                                       ((< color 128)
                                        64)
                                       ((< color 192)
                                        128)
                                       (#t 255))))
           (lut-closest (make-u8lut 256 (lambda (color)
                                          (find-closest-color color))))
           (floyd-luts (build-floyd-steinberg-luts))
           (lut-1-16 (list-ref floyd-luts 0))
           (lut-3-16 (list-ref floyd-luts 1))
           (lut-5-16 (list-ref floyd-luts 2))
           (lut-7-16 (list-ref floyd-luts 3)))
      (let loop-y ((y 0))
        (cond ((fx< y rows)
               (let loop-x ((x 0))
                 (cond ((fx< x cols)
                        (set! oldpixel (matrix-ref mat x y))
                        (set! newpixel (u8fit (lut-closest oldpixel)))
                        (matrix-set! mat2 x y newpixel)
                        (set! quant-error (- oldpixel newpixel))
                        (set! sign (get-sign quant-error))
                        (set! quant-error (abs quant-error))
                        (cond ((and (fx< (fx+ x 1) cols) (fx< (fx+ y 1) rows))
                               (set! pixel (matrix-ref mat (fx+ x 1) y))
                               (matrix-set! mat (fx+ x 1) y (u8fit (+ pixel (* sign (lut-7-16 quant-error)))))
                               (set! pixel (matrix-ref mat (fx- x 1) (fx+ y 1)))
                               (matrix-set! mat (fx- x 1) (fx+ y 1) (u8fit (+ pixel (* sign (lut-3-16 quant-error)))))
                               (set! pixel (matrix-ref mat x (fx+ y 1)))
                               (matrix-set! mat x (fx+ y 1) (u8fit (+ pixel (* sign (lut-5-16 quant-error)))))
                               (set! pixel (matrix-ref mat (fx+ x 1) (fx+ y 1)))
                               (matrix-set! mat (fx+ x 1) (fx+ y 1) (u8fit (+ pixel (* sign (lut-1-16 quant-error)))))))
                        (loop-x (fx+ x 1)))))
               (loop-y (fx+ y 1)))
              (#t img2)))))

  (define (sierra-filter-lite img-gray)
    (let* ((rows (image-rows img-gray)) (cols (image-cols img-gray))
           (img (image-copy img-gray)) (mat (image-channel-matrix img 0))
           (img2 (make-gray-image cols rows)) (mat2 (image-channel-matrix img2 0))
           (oldpixel 0) (newpixel 0) (quant-error 0) (pixel 0) (sign 0)
           (get-sign (lambda (x) (if (negative? x) -1 1)))
           (find-closest-color (lambda (color)
                                 (if (> color 128) 255 0)))
           (lut-closest (make-u8lut 256 (lambda (color)
                                          (find-closest-color color))))
           (sierra-luts (build-sierra-filter-lite-luts))
           (lut-1-4 (list-ref sierra-luts 0))
           (lut-2-4 (list-ref sierra-luts 1)))

      (let loop-y ((y 0))
        (cond ((fx< y rows)
               (let loop-x ((x 0))
                 (cond ((fx< x cols)
                        (set! oldpixel (matrix-ref mat x y))
                        (set! newpixel (u8fit (lut-closest oldpixel)))
                        (matrix-set! mat2 x y newpixel)
                        (set! quant-error (fx- oldpixel newpixel))
                        (set! sign (get-sign quant-error))
                        (set! quant-error (abs quant-error))
                        (cond ((and (fx< (fx+ x 1) cols) (fx< (fx+ y 1) rows))
                               (set! pixel (matrix-ref mat (fx+ x 1) y))
                               (matrix-set! mat (fx+ x 1) y (u8fit (+ pixel (* sign (lut-2-4 quant-error)))))
                               (set! pixel (matrix-ref mat x (fx+ y 1)))
                               (matrix-set! mat x (fx+ y 1) (u8fit (+ pixel (* sign (lut-1-4 quant-error)))))
                               (set! pixel (matrix-ref mat (fx- x 1) (fx+ y 1)))
                               (matrix-set! mat (fx- x 1) (fx+ y 1) (u8fit (+ pixel (* sign (lut-1-4 quant-error)))))))
                        (loop-x (fx+ x 1)))))
               (loop-y (fx+ y 1)))
              (#t img2)))))

  (cond ((equal? method 'error-difusion)
         (floyd-steinberg img-gray))
        ((equal? method 'error-difusion-random)
         (floyd-steinberg-random img-gray))
        ((equal? method 'error-difusion-4-levels)
         (floyd-steinberg-4-colors img-gray))
        ((equal? method 'error-difusion-lite)
         (sierra-filter-lite img-gray))))
