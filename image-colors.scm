;;; $Id: image-colors.scm,v 1.4 2013/03/02 15:54:41 daniel Exp daniel $
;;; $Name:  $

(declare
 (block)
 (inline)
 (inline-primitives)
 (inlining-limit 10000)
 (lambda-lift)
 (constant-fold)
 (standard-bindings)
 (extended-bindings)
 (proper-tail-calls)
 (safe))

;;; color convertion procedures
(define (rgb-to-hsi r g b)
  (let* ((minRGB (fxmin r g b)) (maxRGB (fxmax r g b)) (h 0.0) (s 0.0) (i 0.0))
    (cond ((fx= minRGB maxRGB) ;; in case the color is black and white
           (list h s (exact->inexact minRGB)))
          (#t (let* ((sumRGB (exact->inexact (fx+ r g b))) (r-g (fx- r g)) (r-b (fx- r b)) (g-b (fx- g b))
                     (theta (acos (/ (* 0.5 (+ r-g r-b)) (exact->inexact (sqrt (fx+ (expt r-g 2) (* r-b g-b))))))))
                (if (fx<= b g)
                    (set! h (rad-to-angle theta))
                    (set! h (- 360 (rad-to-angle theta))))
                (set! i (fl/ sumRGB 3.0))
                (set! s (fl- 1.0 (fl/ (exact->inexact (* 3 minRGB)) sumRGB)))
                (list (exact->inexact h) s i))))))

(define (hsi-to-rgb h s i)
  (let* ((ScosH (lambda (x) (fl* s (cos x)))) (cosH (lambda (x) (cos (- (angle-to-rad 60) x))))
         (val1 (lambda (x) (fl* i (+ 1.0 (/ (ScosH x) (cosH x))))))
         (val2 (* i (fl- 1.0 s)))
         (val3 (lambda (a b) (fl- (fl* i 3.0)  (fl+ a b)))) (r 0.0) (g 0.0) (b 0.0))
    (begin (cond ((fl< h 120.0)
                  (set! b val2)
                  (set! r (val1 (angle-to-rad h)))
                  (set! g (val3 r b )))
                 ((and (fl>= h 120.0) (fl< h 240.0))
                  (set! g (val1 (angle-to-rad (- h 120.0))))
                  (set! r val2)
                  (set! b (val3 r g)))
                 (#t
                  (set! b (val1 (angle-to-rad (- h 240.0))))
                  (set! g val2)
                  (set! r (val3 g b))))
           (list  (inexact->exact (round r)) (inexact->exact (round g))  (inexact->exact (round b))))))

(define (rgb-to-gray r g b)
  (+ (* 0.2989 r) (* 0.5870 g) (* 0.1140 b)))

(define (gray-to-rgb gray)
  (list gray gray gray))

;;Gray = 0.2989 * R + 0.5870 * G + 0.1140 * B
(define (rgb-image-to-gray-image img)
  (let* ((m-r (image-channel-matrix img 0)) (size (matrix-size m-r))
         (rows (matrix-rows m-r)) (cols (matrix-cols m-r))
         (vec-r (image-channel-vector img 0)) (vec-g (image-channel-vector img 1))
         (vec-b (image-channel-vector img 2))
         (grayimg (make-gray-image cols rows)) (vec-gray (image-channel-vector grayimg 0)))
    (let loop-i (( i 0))
      (cond ((fx< i size)
             (u8vector-set! vec-gray i
                            (u8fit (exact-round 
                                    (rgb-to-gray
                                     (u8vector-ref vec-r i) (u8vector-ref vec-g i) (u8vector-ref vec-b i)))))
             (loop-i (+ i 1)))
            (else grayimg)))))

(define (rgb-image-to-hsi-image img)
  (let* ((m-r (image-channel-matrix img 0)) (size (matrix-size m-r))
         (cols (matrix-cols m-r)) (rows (matrix-rows m-r))
         (hsi (make-hsi-image cols rows))
         (vec-r (image-channel-vector img 0)) (vec-g (image-channel-vector img 1))
         (vec-b (image-channel-vector img 2)) (h (image-channel-vector hsi 0))
         (s ((image-channel-vector hsi 1)))   (i (image-channel-vector hsi 2)))
    (let loop-k ((k 0))
      (begin (cond ((fx< k size)
                    (let* ((r-k (u8vector-ref vec-r k)) (g-k (u8vector-ref vec-g k)) (b-k (u8vector-ref vec-b k))
                           (color (rgb-to-hsi r-k g-k b-k)))
                      (f32vector-set! h k (car color))
                      (f32vector-set! s k (car (cdr color)))
                      (f32vector-set! i k (car (cdr (cdr color))))
                      (loop-k (+ k 1)))))
             hsi))))

(define (hsi-image-to-rgb-image img)
  (let* ((m-h (image-channel-matrix img 0))  (size (matrix-size m-h))
         (cols (matrix-cols m-h)) (rows (matrix-rows img))
         (rgb (make-rgb-image cols rows))
         (vec-r (image-channel-vector rgb 0)) (vec-g (image-channel-vector rgb 1))
         (vec-b (image-channel-vector rgb 2)) (vec-h (image-channel-vector img 0))
         (vec-s (image-channel-vector img 1)) (vec-i (image-channel-vector img 2)))
    (let loop-k ((k 0))
      (begin (cond ((fx< k size)
                    (let* ((h-k (f32vector-ref vec-h k)) (s-k (f32vector-ref vec-s k)) (i-k (f32vector-ref vec-i k))
                           (color (hsi-to-rgb h-k s-k i-k)))
                      (u8vector-set! vec-r k (car color))
                      (u8vector-set! vec-g k (car (cdr color)))
                      (u8vector-set! vec-b k (car (cdr (cdr color))))
                      (loop-k (+ k 1)))))
             rgb))))
